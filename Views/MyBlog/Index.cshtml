@using Newtonsoft.Json;
@using Newtonsoft.Json.Linq;
@using Quill.Delta;
@model Blog.Models.MainVM

@{
    var generate = ViewBag.generatePost ?? false;

}


<div class="myBlogSpaceMain container bg-light">


    <form method="POST" class="sendPostForm mb-5" asp-action="SavePost" enctype="multipart/form-data">

        <div asp-validation-summary="ModelOnly" class="text-danger"> </div>

        <!-- title input -->

        <div class="form-outline mb-4">
            <label class="form-label" asp-for="TextEditor.Title"></label>
            <div>
                <input asp-for="TextEditor.Title" name="Title" class="form-control" />
                <span asp-validation-for="TextEditor.Title" class="text-danger"></span>
            </div>
        </div>

        <!-- body input -->

        <div class="form-outline mb-4">
            <label class="form-label" asp-for="TextEditor.RichContent"></label>
            <div>
                <textarea id="richTextEditor" name="richContent" asp-for="TextEditor.RichContent" class="form-control"></textarea>
                <span asp-validation-for="TextEditor.RichContent" class="text-danger"></span>
            </div>
        </div>


        <input type="Submit" class="btn btn-success bg-gradient" value="Create Post" />
    </form>

    <div id="partialViewContainer">

            @if (Model.PostsList != null)
            {
                @foreach (var post in Model.PostsList)
                {
                    <div class="fr-wrapper displayPostCustomBox">

                        <div class="fr-element fr-view">

                            <div class="d-flex justify-content-between rounded-1 bg-dark bg-gradient text-light p-2">

                                <h3>@post.Title</h3>

                                <div class="d-flex displayPostCustomHeader">

                                    <div class="mx-3 displayPostCustomDate">Created: @post.CreatedAt</div>
                                        
                                    <span data-value="@post.Id" class="material-symbols-outlined displayPostCustomDeletePost">
                                        delete
                                    </span>

                                    <div class="displayPostCustomDeletePostConfirmBox">

                                        <div class="acceptDeletePost">
                                            <span class="material-symbols-outlined">
                                                done
                                            </span>
                                        </div>

                                        <div class="cancelDeletePost">
                                            <span class="material-symbols-outlined">
                                                close
                                            </span>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mt-5">
                                @Html.Raw(post.Content)
                            </div>

                        </div>
                    </div>
                }
            }
    </div>

    
</div>

@section Scripts{

    <script>

        // Get all the delete buttons
        let deleteButtons = document.querySelectorAll('.displayPostCustomDeletePost');

        //Rich text editor
        let editor = new FroalaEditor('#richTextEditor');

        //Form
        var form = document.querySelector('.sendPostForm');

        form.onsubmit = async function (e) {
            e.preventDefault();

            const postTitle = document.querySelector('input[name=Title]').value;
            const richTextContent = document.querySelector('textarea[name=richContent]').value;

        //This code defines an asynchronous function convertToBase64 that takes a URL as a parameter.It uses the Fetch API to fetch the resource at the given URL, retrieves the response as a blob, and then converts the blob to a base64 - encoded string using a FileReader.The function returns a promise that resolves with the base64 string.
            const convertToBase64 = async (url) => {
                const response = await fetch(url);
                const blob = await response.blob();
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            };


            //These lines define an empty array promises and use the replace() method with a regular expression to iterate over the img tags in the richTextContent string. For each img tag, it extracts the value of the src attribute using a regex match. If the src value doesn't start with 'http' or 'https', indicating it's a local file, it calls the convertToBase64 function with the src value and adds the resulting promise to the promises array. The replace() method returns the updated content with the original img tags unchanged.
            const promises = [];
            const updatedContent = richTextContent.replace(/<img([^>]+)>/g, (match, p1) => {
                const srcMatch = p1.match(/src\s*=\s*(['"])(.*?)\1/);
                if (srcMatch) {
                    const src = srcMatch[2];
                    if (!src.startsWith('http') && !src.startsWith('https')) {
                        const base64Promise = convertToBase64(src);
                        promises.push(base64Promise);
                        return match;
                    }
                }
                return match;
            });

            //These lines use Promise.all() to await all the promises in the promises array. This ensures that all the base64 conversions are completed before further processing. The resulting array of base64 strings is stored in the base64Array variable. The code then uses the replace() method again to iterate over the img tags in the updatedContent string. It checks if the src value indicates a local file, and if so, replaces it with the corresponding base64 string from the base64Array. This updates the src attribute of the img tags with the base64-encoded images.
            const base64Array = await Promise.all(promises);
            let base64Index = 0;
            const updatedContentWithBase64 = updatedContent.replace(/<img([^>]+)>/g, (match, p1) => {
                const srcMatch = p1.match(/src\s*=\s*(['"])(.*?)\1/);
                if (srcMatch) {
                    const src = srcMatch[2];
                    if (!src.startsWith('http') && !src.startsWith('https')) {
                        const base64 = base64Array[base64Index];
                        base64Index++;
                        return match.replace(src, base64);
                    }
                }
                return match;
            });

            var form = $(this);
            var url = form.attr('action');

            const formData = new FormData();
            formData.append('RichContent', updatedContentWithBase64);
            formData.append('Title', postTitle);

            $.ajax({
                url: url,
                type: 'POST',
                data: formData,
                processData: false,
                contentType: false,
                success: function (data) {

                    // Create a jQuery element from the data
                    const newPost = $(data);

                    // Insert the new post at the top of the list
                    $('#partialViewContainer').prepend(newPost);

                },
                error: function (xhr, status, error) {
                    var errorMessage = xhr.responseText || 'An error occurred.';
                    alert('Error: ' + errorMessage);
                    console.log(errorMessage);
                }
            });

            return false;
        };



        //DELETE POST

        const partialViewContainer = document.getElementById('partialViewContainer');

        partialViewContainer.addEventListener('click', function (e) {

            if (e.target.matches('.displayPostCustomDeletePost')) {

                const deleteButton = e.target;
                const postId = parseInt(deleteButton.getAttribute('data-value'));
                
                const confirmBox = deleteButton.nextElementSibling;

                const deletePost = confirmBox.querySelector('.acceptDeletePost');
                const cancelDelete = confirmBox.querySelector('.cancelDeletePost');

                //Get main box
                const postContainer = deleteButton.closest('.displayPostCustomBox');
                const dateDisplay = postContainer.querySelector('.displayPostCustomDate');

                $(deleteButton).effect("bounce", { times: 2 }, "fast", function () {

                    deleteButton.classList.add('hideDeleteButton');
                    confirmBox.style.display = "flex";

                });

                //Remove styles
                deleteButton.classList.remove('showDeleteButton');

                //Cancel delete post
                cancelDelete.addEventListener('click', () => {

                    deleteButton.classList.remove('hideDeleteButton');
                    deleteButton.classList.add('showDeleteButton');
                    confirmBox.style.display = "none";
                });

                //Delete post
                deletePost.addEventListener('click', () => {

                    $(postContainer).effect("shake", { times: 3 }, "mid", function () {

                        postContainer.classList.add('removePostBox');
                        //console.log(postContainer.)
                        
                        $.post("@Url.Action("DeletePost", "MyBlog")", { postId: postId }, function (data) {

                            postContainer.remove();

                        });

                    });
                });

            }
        });



    </script>
}